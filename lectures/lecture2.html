<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2. Lecture #2 &mdash; CS 428 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="CS 428 1.0 documentation" href="../index.html" />
    <link rel="prev" title="1. Lecture #1" href="lecture1.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="lecture1.html" title="1. Lecture #1"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CS 428 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lecture-2">
<h1>2. Lecture #2<a class="headerlink" href="#lecture-2" title="Permalink to this headline">Â¶</a></h1>
<p>We continue our discussion about OpenGL, and learn about <cite>vertex</cite> and <cite>fragment</cite>
shaders. The following code shows how to draw two triangles with different
colors.</p>
<div class="line-block">
<div class="line"><strong>Scribe Notes by Anna Faytelson:</strong> <a class="reference external" href="../scribe_notes/lecture2_notes_Anna_Faytelson.zip">Source1</a> <a class="reference external" href="../scribe_notes/lecture2_notes_Anna_Faytelson.pdf">PDF1</a></div>
<div class="line"><strong>Scribe Notes by Abhishek Sutrave:</strong> <a class="reference external" href="../scribe_notes/lecture2_notes_Abhishek_Sutrave.docx">Source2</a> <a class="reference external" href="../scribe_notes/lecture2_notes_Abhishek_Sutrave.pdf">PDF2</a></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>#include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#include &lt;iostream&gt;

void key_callback(GLFWwindow* window,int key,int scancode,int action,int mode)
{
    if(key==GLFW_KEY_ESCAPE &amp;&amp; action==GLFW_PRESS)
        glfwSetWindowShouldClose(window,GL_TRUE);
}

// vertex shader
const GLchar* vertex_shader_source=&quot;# version 330 core\n&quot;
        &quot;layout (location=0) in vec3 position;\n&quot;
        &quot;void main()\n&quot;
        &quot;{\n&quot;
        &quot;gl_Position = vec4(position.x,position.y,position.z,1.0);\n&quot;
        &quot;}\0&quot;;

// fragment shaders
const GLchar* fragment_shader_source1=&quot;# version 330 core\n&quot;
        &quot;out vec4 color;\n&quot;
        &quot;void main()\n&quot;
        &quot;{\n&quot;
        &quot;color=vec4(1.0f,0.5f,0.2f,1.0f);\n&quot;
        &quot;}\0&quot;;

const GLchar* fragment_shader_source2=&quot;# version 330 core\n&quot;
        &quot;out vec4 color;\n&quot;
        &quot;void main()\n&quot;
        &quot;{\n&quot;
        &quot;color=vec4(1.0f,1.0f,0.0f,1.0f);\n&quot;
        &quot;}\0&quot;;

int main()
{
    glfwInit();
#if __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT,GL_TRUE);
#endif
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,3);
    glfwWindowHint(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_RESIZABLE,GL_FALSE);

    GLFWwindow *window=glfwCreateWindow(800,600,&quot;Learn OpenGL&quot;,nullptr,nullptr);
    if(window==nullptr)
    {
        std::cout&lt;&lt;&quot;Failed to create GLFW window!&quot;&lt;&lt;std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);

    glewExperimental=GL_TRUE;
    if(glewInit()!=GLEW_OK)
    {
        std::cout&lt;&lt;&quot;Failed to initialize GLEW!&quot;&lt;&lt;std::endl;
        return -1;
    }

    int width,height;
    glfwGetFramebufferSize(window,&amp;width,&amp;height);
    glViewport(0,0,width,height);

    glfwSetKeyCallback(window,key_callback);

    GLfloat vertices[]={
         0.5f,  0.5f, 0.0f,
         0.5f, -0.5f, 0.0f,
        -0.5f, -0.5f, 0.0f,
        -0.5f,  0.5f, 0.0f
    };

    GLuint indices1[]={
        0, 1, 3
    };

    GLuint indices2[]={
        1, 2, 3
    };

    // create vertex buffer object
    GLuint VBO;
    glGenBuffers(1,&amp;VBO);

    // create element buffer objects
    GLuint EBO[2];
    glGenBuffers(2,EBO);

    // vertex shader
    GLuint vertex_shader=glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertex_shader,1,&amp;vertex_shader_source,NULL);
    glCompileShader(vertex_shader);

    GLint success;
    GLchar info_log[512];
    glGetShaderiv(vertex_shader,GL_COMPILE_STATUS,&amp;success);
    if(!success)
    {
        glGetShaderInfoLog(vertex_shader,512,NULL,info_log);
        std::cout&lt;&lt;&quot;Error! Vertex Shader::Compilation Failed!&quot;&lt;&lt;std::endl&lt;&lt;info_log&lt;&lt;std::endl;
    }

    // fragment shaders
    GLuint fragment_shader1=glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragment_shader1,1,&amp;fragment_shader_source1,NULL);
    glCompileShader(fragment_shader1);

    glGetShaderiv(fragment_shader1,GL_COMPILE_STATUS,&amp;success);
    if(!success)
    {
        glGetShaderInfoLog(fragment_shader1,512,NULL,info_log);
        std::cout&lt;&lt;&quot;Error! Fragment Shader::Compilation Failed!&quot;&lt;&lt;std::endl&lt;&lt;info_log&lt;&lt;std::endl;
    }

    GLuint fragment_shader2=glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragment_shader2,1,&amp;fragment_shader_source2,NULL);
    glCompileShader(fragment_shader2);

    glGetShaderiv(fragment_shader2,GL_COMPILE_STATUS,&amp;success);
    if(!success)
    {
        glGetShaderInfoLog(fragment_shader2,512,NULL,info_log);
        std::cout&lt;&lt;&quot;Error! Fragment Shader::Compilation Failed!&quot;&lt;&lt;std::endl&lt;&lt;info_log&lt;&lt;std::endl;
    }

    // shader programs
    GLuint shader_program1=glCreateProgram();
    glAttachShader(shader_program1,vertex_shader);
    glAttachShader(shader_program1,fragment_shader1);
    glLinkProgram(shader_program1);

    glGetProgramiv(shader_program1,GL_LINK_STATUS,&amp;success);
    if(!success)
    {
        glGetProgramInfoLog(shader_program1,512,NULL,info_log);
        std::cout&lt;&lt;&quot;Error! Shader Program::Linking Failed!&quot;&lt;&lt;std::endl&lt;&lt;info_log&lt;&lt;std::endl;
    }

    GLuint shader_program2=glCreateProgram();
    glAttachShader(shader_program2,vertex_shader);
    glAttachShader(shader_program2,fragment_shader2);
    glLinkProgram(shader_program2);

    glGetProgramiv(shader_program2,GL_LINK_STATUS,&amp;success);
    if(!success)
    {
        glGetProgramInfoLog(shader_program2,512,NULL,info_log);
        std::cout&lt;&lt;&quot;Error! Shader Program::Linking Failed!&quot;&lt;&lt;std::endl&lt;&lt;info_log&lt;&lt;std::endl;
    }

    glDeleteShader(vertex_shader);
    glDeleteShader(fragment_shader1);
    glDeleteShader(fragment_shader2);

    // create vertex array objects
    GLuint VAO[2];
    glGenVertexArrays(2,VAO);

    // bind vertex array object
    glBindVertexArray(VAO[0]);
    // copy the vertices in a vertex buffer
    glBindBuffer(GL_ARRAY_BUFFER,VBO);
    glBufferData(GL_ARRAY_BUFFER,sizeof(vertices),vertices,GL_STATIC_DRAW);
    // copy the index array in an element buffer
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,EBO[0]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER,sizeof(indices1),indices1,GL_STATIC_DRAW);
    // set vertex attribute pointers
    glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,3*sizeof(GL_FLOAT),(GLvoid*)0);
    glEnableVertexAttribArray(0);
    // unbind the vertex array object
    glBindVertexArray(0);

    // bind vertex array object
    glBindVertexArray(VAO[1]);
    // copy the vertices in a vertex buffer
    glBindBuffer(GL_ARRAY_BUFFER,VBO);
    glBufferData(GL_ARRAY_BUFFER,sizeof(vertices),vertices,GL_STATIC_DRAW);
    // copy the index array in an element buffer
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,EBO[1]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER,sizeof(indices2),indices2,GL_STATIC_DRAW);
    // set vertex attribute pointers
    glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,3*sizeof(GL_FLOAT),(GLvoid*)0);
    glEnableVertexAttribArray(0);
    // unbind the vertex array object
    glBindVertexArray(0);

    //glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);

    while(!glfwWindowShouldClose(window))
    {
        glfwPollEvents();

        glClearColor(.2f,.3f,.3f,1.f);
        glClear(GL_COLOR_BUFFER_BIT);

        // use shader programs
        glUseProgram(shader_program1);
        glBindVertexArray(VAO[0]);
        glDrawElements(GL_TRIANGLES,3,GL_UNSIGNED_INT,0);
        glBindVertexArray(0);

        glUseProgram(shader_program2);
        glBindVertexArray(VAO[1]);
        glDrawElements(GL_TRIANGLES,3,GL_UNSIGNED_INT,0);
        glBindVertexArray(0);

        glfwSwapBuffers(window);
    }

    // deallocate all resources
    glDeleteVertexArrays(2,VAO);
    glDeleteBuffers(1,&amp;VBO);
    glDeleteBuffers(2,EBO);
    // terminate GLFW
    glfwTerminate();

    return 0;
}
</pre></div>
</div>
<p>Save this file as <code class="docutils literal"><span class="pre">main.cpp</span></code>. To compile the code, run the following command:</p>
<div class="highlight-python"><div class="highlight"><pre>g++ -O3 main.cpp -o triangle -lGLEW -lglfw -lGL -lX11 -lpthread -lXrandr -ldl -lXxf86vm -lXinerama -lXcursor -lrt -lm -std=c++11
</pre></div>
</div>
<p>This will create a binary <code class="docutils literal"><span class="pre">triangle</span></code>, and now if you execute the following command:</p>
<div class="highlight-python"><div class="highlight"><pre>./triangle
</pre></div>
</div>
<p>then you should see a new window (like the one shown below) pop-up on your screen:</p>
<a class="reference internal image-reference" href="../_images/triangles.png"><img alt="../_images/triangles.png" class="align-center" src="../_images/triangles.png" style="width: 32%;" /></a>
<p>Execute the following command to run this code on Mac OS:</p>
<div class="highlight-python"><div class="highlight"><pre>g++ -O3 main.cpp -o triangle -lGLEW -lglfw -framework OpenGL -ldl -lm -std=c++11
</pre></div>
</div>
<p>As you can see, writing OpenGL code can quickly become quite cumbersome as many
initializations and checks need to be executed to make sure that everything was
setup correctly. However, this is where we can exploit the power of C++, in
particular, its <em>Object-Oriented Principle</em> to reduce code complexity. In the
following example, we will create a new class <code class="docutils literal"><span class="pre">Shader</span></code> that will abstract away
from the user all the intricacies involved in creating a new shader program,
making it much easier and user-friendly.</p>
<div class="highlight-python"><div class="highlight"><pre>#ifndef SHADER_H
#define SHADER_H

#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;

#include &lt;GL/glew.h&gt;

class Shader
{
  public:
    // the shader program id
    GLuint program;

    Shader(const GLchar* vertex_path,const GLchar* fragment_path)
    {
        // retrieve the vertex/fragment source code
        std::string vertex_code,fragment_code;
        std::ifstream vertex_shader_file,fragment_shader_file;

        // ensures ifstream objects can throw exceptions
        vertex_shader_file.exceptions(std::ifstream::badbit);
        fragment_shader_file.exceptions(std::ifstream::badbit);

        try{
            // open files
            vertex_shader_file.open(vertex_path);
            fragment_shader_file.open(fragment_path);
            std::stringstream vertex_shader_stream,fragment_shader_stream;

            // read file&#39;s buffer contents into streams
            vertex_shader_stream&lt;&lt;vertex_shader_file.rdbuf();
            fragment_shader_stream&lt;&lt;fragment_shader_file.rdbuf();

            // close file handlers
            vertex_shader_file.close();
            fragment_shader_file.close();

            // convert stream into string
            vertex_code=vertex_shader_stream.str();
            fragment_code=fragment_shader_stream.str();
        }
        catch(std::ifstream::failure e){
            std::cout&lt;&lt;&quot;Error::Shader::File Not Successfully Read!&quot;&lt;&lt;std::endl;
        }

        const GLchar* vertex_shader_code=vertex_code.c_str();
        const GLchar* fragment_shader_code=fragment_code.c_str();

        // compile shaders
        GLuint vertex,fragment;
        GLint success;
        GLchar info_log[512];

        // vertex shader
        vertex=glCreateShader(GL_VERTEX_SHADER);
        glShaderSource(vertex,1,&amp;vertex_shader_code,NULL);
        glCompileShader(vertex);
        // print compile errors if any
        glGetShaderiv(vertex,GL_COMPILE_STATUS,&amp;success);
        if(!success)
        {
            glGetShaderInfoLog(vertex,512,NULL,info_log);
            std::cout&lt;&lt;&quot;Error::Shader::Vertex::Compilation Failed!&quot;&lt;&lt;std::endl&lt;&lt;info_log&lt;&lt;std::endl;
        }

        // fragment shader
        fragment=glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(fragment,1,&amp;fragment_shader_code,NULL);
        glCompileShader(fragment);
        // print compile errors if any
        glGetShaderiv(fragment,GL_COMPILE_STATUS,&amp;success);
        if(!success)
        {
            glGetShaderInfoLog(fragment,512,NULL,info_log);
            std::cout&lt;&lt;&quot;Error::Shader::Fragment::Compilation Failed!&quot;&lt;&lt;std::endl&lt;&lt;info_log&lt;&lt;std::endl;
        }

        // shader program
        this-&gt;program=glCreateProgram();
        glAttachShader(this-&gt;program,vertex);
        glAttachShader(this-&gt;program,fragment);
        glLinkProgram(this-&gt;program);
        // print linking errors if any
        glGetProgramiv(this-&gt;program,GL_LINK_STATUS,&amp;success);
        if(!success)
        {
            glGetProgramInfoLog(this-&gt;program,512,NULL,info_log);
            std::cout&lt;&lt;&quot;Error::Shader::Program::Linking Failed!&quot;&lt;&lt;std::endl&lt;&lt;info_log&lt;&lt;std::endl;
        }

        // delete the shaders as they are now linked into our program and no longer necessary
        glDeleteShader(vertex);
        glDeleteShader(fragment);
    }

    void Use()
    {glUseProgram(this-&gt;program);}
};
#endif
</pre></div>
</div>
<p>Save the above code in a file called <code class="docutils literal"><span class="pre">Shader.h</span></code>. Now open up a new file and
type in the following code below:</p>
<div class="highlight-python"><div class="highlight"><pre>#include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#include &lt;cmath&gt;

#include &quot;Shader.h&quot;

void key_callback(GLFWwindow* window,int key,int scancode,int action,int mode)
{
    if(key==GLFW_KEY_ESCAPE &amp;&amp; action==GLFW_PRESS)
        glfwSetWindowShouldClose(window,GL_TRUE);
}

int main()
{
    glfwInit();
#if __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT,GL_TRUE);
#endif
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,3);
    glfwWindowHint(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_RESIZABLE,GL_FALSE);

    GLFWwindow *window=glfwCreateWindow(800,600,&quot;Learn OpenGL&quot;,nullptr,nullptr);
    if(window==nullptr)
    {
        std::cout&lt;&lt;&quot;Failed to create GLFW window!&quot;&lt;&lt;std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);

    glewExperimental=GL_TRUE;
    if(glewInit()!=GLEW_OK)
    {
        std::cout&lt;&lt;&quot;Failed to initialize GLEW!&quot;&lt;&lt;std::endl;
        return -1;
    }

    int width,height;
    glfwGetFramebufferSize(window,&amp;width,&amp;height);
    glViewport(0,0,width,height);

    glfwSetKeyCallback(window,key_callback);

    Shader our_shader(&quot;shader.vs&quot;,&quot;shader.frag&quot;);

    GLfloat vertices[]={
        // positions        // colors
        -0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f,
         0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f,
         0.0f,  0.5f, 0.0f, 0.0f, 0.0f, 1.0f
    };

    GLuint VAO,VBO;
    glGenBuffers(1,&amp;VBO);
    glGenVertexArrays(1,&amp;VAO);

    // bind vertex array object
    glBindVertexArray(VAO);

    // copy the vertices in a buffer
    glBindBuffer(GL_ARRAY_BUFFER,VBO);
    glBufferData(GL_ARRAY_BUFFER,sizeof(vertices),vertices,GL_STATIC_DRAW);

    // set position attribute pointers
    glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,6*sizeof(GL_FLOAT),(GLvoid*)0);
    glEnableVertexAttribArray(0);
    // set color attribute pointers
    glVertexAttribPointer(1,3,GL_FLOAT,GL_FALSE,6*sizeof(GL_FLOAT),(GLvoid*)(3*sizeof(GLfloat)));
    glEnableVertexAttribArray(1);

    // unbind the vertex array object
    glBindVertexArray(0);

    while(!glfwWindowShouldClose(window))
    {
        glfwPollEvents();
        glClearColor(.2f,.3f,.3f,1.f);
        glClear(GL_COLOR_BUFFER_BIT);

        // use shader program
        our_shader.Use();

        // draw
        glBindVertexArray(VAO);
        glDrawArrays(GL_TRIANGLES,0,3);
        glBindVertexArray(0);

        glfwSwapBuffers(window);
    }

    // deallocate all resources
    glDeleteVertexArrays(1,&amp;VAO);
    glDeleteBuffers(1,&amp;VBO);
    // terminate GLFW
    glfwTerminate();

    return 0;
}
</pre></div>
</div>
<p>Save this file as <code class="docutils literal"><span class="pre">main.cpp</span></code>. You will need to create two additional files for
the vertex and fragment shaders. Open a new file and type the following code:</p>
<div class="highlight-python"><div class="highlight"><pre>#version 330 core
layout (location=0) in vec3 position;
layout (location=1) in vec3 color;

out vec3 our_color;

void main()
{
    gl_Position=vec4(position,1.0f);
    our_color=color;
}
</pre></div>
</div>
<p>Save this file as <code class="docutils literal"><span class="pre">shader.vs</span></code>. Open another file and type the following
command:</p>
<div class="highlight-python"><div class="highlight"><pre>#version 330 core
in vec3 our_color;
out vec4 color;

void main()
{
    color=vec4(our_color,1.0f);
}
</pre></div>
</div>
<p>Save this file as <code class="docutils literal"><span class="pre">shader.frag</span></code>. If you did everything right, then you should
see four new files in your folder now: <code class="docutils literal"><span class="pre">Shader.h</span></code>, <code class="docutils literal"><span class="pre">main.cpp</span></code>,
<code class="docutils literal"><span class="pre">shader.vs</span></code>, and <code class="docutils literal"><span class="pre">shader.frag</span></code>. To compile the code, run the following
command:</p>
<div class="highlight-python"><div class="highlight"><pre>g++ -O3 main.cpp -o triangle -lGLEW -lglfw -lGL -lX11 -lpthread -lXrandr -ldl -lXxf86vm -lXinerama -lXcursor -lrt -lm -std=c++11
</pre></div>
</div>
<p>This will create a binary <code class="docutils literal"><span class="pre">triangle</span></code>, and now if you execute the following command:</p>
<div class="highlight-python"><div class="highlight"><pre>./triangle
</pre></div>
</div>
<p>then you should see a new window (like the one shown below) pop-up on your screen:</p>
<a class="reference internal image-reference" href="../_images/multi-color-triangle.png"><img alt="../_images/multi-color-triangle.png" class="align-center" src="../_images/multi-color-triangle.png" style="width: 32%;" /></a>
<p>Execute the following command to run this code on Mac OS:</p>
<div class="highlight-python"><div class="highlight"><pre>g++ -O3 main.cpp -o triangle -lGLEW -lglfw -framework OpenGL -ldl -lm -std=c++11
</pre></div>
</div>
<p>Note that this example is a bit different from the previous example, in the
sense that we specified a <em>color</em> attribute per vertex (unlike the previous
example where color was associated with the fragment shader). In this case, the
fragment shader <em>automatically</em> blends the colors, as shown above.</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="lecture1.html"
                        title="previous chapter">1. Lecture #1</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/lectures/lecture2.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="lecture1.html" title="1. Lecture #1"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CS 428 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2019, Mridul Aanjaneya.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>